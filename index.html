<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Sicilia — ICON-2I</title>

  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body { height:100%; margin:0; }
    #map { height:100%; width:100%; }

    .panel{
      position:absolute; top:12px; left:12px;
      width:min(320px, calc(100vw - 24px));
      background:rgba(20,24,33,.82);
      color:#eef2ff;
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
      padding:12px 12px 10px 12px;
      z-index:9999;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height:1.25;
      user-select:none;
    }
    .panel h1{
      margin:0 0 10px 0;
      font-size:16px;
      font-weight:700;
      letter-spacing:.2px;
    }
    .btn{
      width:100%;
      border:0;
      background:rgba(60,80,255,.25);
      color:#fff;
      padding:10px 12px;
      border-radius:10px;
      font-weight:700;
      cursor:pointer;
    }
    .btn:active{ transform: translateY(1px); }

    .row{ display:flex; gap:10px; align-items:center; margin:10px 0; }
    .checks{ display:flex; flex-direction:column; gap:10px; margin:10px 0 12px 0; }
    label{ display:flex; align-items:center; gap:10px; font-size:14px; }
    input[type="checkbox"]{ width:18px; height:18px; }

    .meta{ font-size:12px; opacity:.92; margin-top:8px; }
    .meta div{ margin:2px 0; }

    .sliderWrap{ margin-top:10px; }
    input[type="range"]{ width:100%; }

    .err{ color:#ffb4b4; font-size:12px; margin-top:8px; white-space:pre-wrap; }

    /* Tooltip info punto */
    .infoTag{
      position:absolute;
      transform: translate(-50%, calc(-100% - 12px));
      background: rgba(10,12,18,.90);
      color:#fff;
      padding:8px 10px;
      border-radius:10px;
      font-size:13px;
      box-shadow:0 10px 24px rgba(0,0,0,.35);
      pointer-events:none;
      z-index:10000;
      max-width: 260px;
      display:none;
    }
    .infoTag .k{ opacity:.8; font-size:12px; }
    .infoTag .v{ font-weight:800; font-size:14px; margin-top:2px; }

    /* canvases */
    .leaflet-overlay-pane canvas { image-rendering: auto; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel" id="panel">
    <h1>Sicilia — ICON-2I</h1>
    <button class="btn" id="reloadBtn">Ricarica dati</button>

    <div class="checks">
      <label><input type="checkbox" id="chkTemp"> Temperatura 2m</label>
      <label><input type="checkbox" id="chkRain"> Pioggia (oraria)</label>
      <label><input type="checkbox" id="chkPres"> Pressione</label>
      <label><input type="checkbox" id="chkWind"> Vento (particelle)</label>
    </div>

    <div class="sliderWrap">
      <div class="meta">
        <div><b>Ora previsione:</b> <span id="timeLabel">—</span></div>
        <input type="range" id="stepSlider" min="0" max="0" step="1" value="0" disabled />
        <div><b>Run:</b> <span id="runLabel">—</span></div>
        <div><b>Punto:</b> <span id="ptLabel">—</span></div>
        <div><b>Valore:</b> <span id="valLabel">—</span></div>
        <div><b>Fonte dati:</b> <span id="srcLabel">—</span></div>
      </div>
    </div>

    <div class="err" id="errBox" style="display:none;"></div>
  </div>

  <div class="infoTag" id="infoTag">
    <div class="k" id="infoTagK">—</div>
    <div class="v" id="infoTagV">—</div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* =========================
       CONFIG (adatta qui se serve)
       ========================= */
    const DATA_DIR = "data";
    const STEPS_DEFAULT = 49;       // se run.json manca, slider assume 0..48
    const STEP_HOURS_DEFAULT = 1;   // step in ore
    const TZ = "Europe/Rome";

    // nomi file: temp_000.json, rain_000.json, pres_000.json, wind_000.json
    const FILES = {
      temp: (i) => `${DATA_DIR}/temp_${String(i).padStart(3,"0")}.json`,
      rain: (i) => `${DATA_DIR}/rain_${String(i).padStart(3,"0")}.json`,
      pres: (i) => `${DATA_DIR}/pres_${String(i).padStart(3,"0")}.json`,
      wind: (i) => `${DATA_DIR}/wind_${String(i).padStart(3,"0")}.json`,
      runMeta: () => `${DATA_DIR}/run.json`
    };

    // Se la pioggia nei tuoi file è ACCUMULATA (0..t), metti true e la trasformiamo in ORARIA.
    // Se invece è già ORARIA, metti false.
    const RAIN_IS_ACCUMULATED = false;

    // palette vento (km/h): blu -> rosso scuro
    function windColor(kmh){
      // clamp 0..80 (oltre 80 resta rosso scuro)
      const x = Math.max(0, Math.min(80, kmh)) / 80;
      // gradient manuale (blu -> ciano -> verde -> giallo -> arancio -> rosso -> rosso scuro)
      const stops = [
        {t:0.00, c:[  0,  90,255]},
        {t:0.20, c:[  0, 200,255]},
        {t:0.40, c:[  0, 255,140]},
        {t:0.60, c:[ 255,255,  0]},
        {t:0.75, c:[ 255,140,  0]},
        {t:0.90, c:[ 255, 40,  0]},
        {t:1.00, c:[ 120,  0,  0]},
      ];
      let a=stops[0], b=stops[stops.length-1];
      for(let i=0;i<stops.length-1;i++){
        if(x>=stops[i].t && x<=stops[i+1].t){ a=stops[i]; b=stops[i+1]; break; }
      }
      const u = (x-a.t)/Math.max(1e-9,(b.t-a.t));
      const r = Math.round(a.c[0] + (b.c[0]-a.c[0])*u);
      const g = Math.round(a.c[1] + (b.c[1]-a.c[1])*u);
      const b2= Math.round(a.c[2] + (b.c[2]-a.c[2])*u);
      return `rgb(${r},${g},${b2})`;
    }

    /* =========================
       SAFE JSON loader (accetta NaN)
       ========================= */
    async function fetchJsonLoose(url){
      const bust = (url.includes("?") ? "&" : "?") + "v=" + Date.now();
      const res = await fetch(url + bust, {cache:"no-store"});
      if(!res.ok) throw new Error(`HTTP ${res.status} su ${url}`);
      const txt = await res.text();
      // rende valido JSON: NaN -> null, Infinity -> null
      const fixed = txt
        .replace(/\bNaN\b/g, "null")
        .replace(/\bInfinity\b/g, "null")
        .replace(/\b-Infinity\b/g, "null");
      return JSON.parse(fixed);
    }

    function setError(msg){
      const box = document.getElementById("errBox");
      if(!msg){
        box.style.display="none";
        box.textContent="";
        return;
      }
      box.style.display="block";
      box.textContent = msg;
    }

    /* =========================
       MAP init
       ========================= */
    const map = L.map("map", { zoomControl:true }).setView([37.55, 14.25], 7);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: "&copy; OpenStreetMap"
    }).addTo(map);

    /* =========================
       Canvas overlay base (scalar fields)
       ========================= */
    function createCanvasOverlay(){
      const overlay = L.Layer.extend({
        onAdd: function(m){
          this._map = m;
          this._canvas = L.DomUtil.create("canvas", "leaflet-layer");
          this._canvas.style.position = "absolute";
          this._ctx = this._canvas.getContext("2d", {alpha:true});
          m.getPanes().overlayPane.appendChild(this._canvas);
          m.on("moveend zoomend resize", this._reset, this);
          this._reset();
        },
        onRemove: function(m){
          m.getPanes().overlayPane.removeChild(this._canvas);
          m.off("moveend zoomend resize", this._reset, this);
        },
        _reset: function(){
          const size = this._map.getSize();
          this._canvas.width = size.x;
          this._canvas.height = size.y;
          const pos = this._map.containerPointToLayerPoint([0,0]);
          L.DomUtil.setPosition(this._canvas, pos);
          if(this._drawFn) this._drawFn();
        },
        setDrawFunction(fn){
          this._drawFn = fn;
          if(this._map) this._reset();
        },
        clear(){
          if(!this._ctx) return;
          this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height);
        },
        get ctx(){ return this._ctx; },
        get canvas(){ return this._canvas; }
      });
      return new overlay();
    }

    const scalarOverlay = createCanvasOverlay().addTo(map);

    /* =========================
       Wind particles overlay
       ========================= */
    function createWindOverlay(){
      const overlay = L.Layer.extend({
        onAdd: function(m){
          this._map = m;
          this._canvas = L.DomUtil.create("canvas", "leaflet-layer");
          this._canvas.style.position = "absolute";
          this._ctx = this._canvas.getContext("2d", {alpha:true});
          m.getPanes().overlayPane.appendChild(this._canvas);
          m.on("moveend zoomend resize", this._reset, this);
          this._running = false;
          this._particles = [];
          this._reset();
        },
        onRemove: function(m){
          this.stop();
          m.getPanes().overlayPane.removeChild(this._canvas);
          m.off("moveend zoomend resize", this._reset, this);
        },
        _reset: function(){
          const size = this._map.getSize();
          this._canvas.width = size.x;
          this._canvas.height = size.y;
          const pos = this._map.containerPointToLayerPoint([0,0]);
          L.DomUtil.setPosition(this._canvas, pos);
        },
        setField(field){
          // field: {nx,ny,bbox,u[],v[]}, bbox=[lonmin,latmin,lonmax,latmax]
          this._field = field || null;
          this._particles = [];
          if(this._field) this._seedParticles(1200);
        },
        _seedParticles(n){
          const w = this._canvas.width, h = this._canvas.height;
          this._particles = [];
          for(let i=0;i<n;i++){
            this._particles.push({
              x: Math.random()*w,
              y: Math.random()*h,
              age: Math.random()*100
            });
          }
        },
        start(){
          if(this._running) return;
          this._running = true;
          const tick = () => {
            if(!this._running) return;
            this._step();
            this._raf = requestAnimationFrame(tick);
          };
          this._raf = requestAnimationFrame(tick);
        },
        stop(){
          this._running = false;
          if(this._raf) cancelAnimationFrame(this._raf);
          this._raf = null;
          if(this._ctx) this._ctx.clearRect(0,0,this._canvas.width,this._canvas.height);
        },
        _sampleUV(px, py){
          const f = this._field;
          if(!f) return null;

          // px/py -> latlng
          const ll = this._map.containerPointToLatLng([px, py]);
          const lon = ll.lng, lat = ll.lat;

          const lonMin = f.bbox[0], latMin = f.bbox[1], lonMax = f.bbox[2], latMax = f.bbox[3];
          if(lon < lonMin || lon > lonMax || lat < latMin || lat > latMax) return null;

          // normalize to grid
          const x = (lon - lonMin) / (lonMax - lonMin) * (f.nx - 1);
          const y = (latMax - lat) / (latMax - latMin) * (f.ny - 1); // lat inverted: top=latMax

          const x0 = Math.floor(x), y0 = Math.floor(y);
          const x1 = Math.min(f.nx-1, x0+1), y1 = Math.min(f.ny-1, y0+1);
          const tx = x - x0, ty = y - y0;

          const idx = (xx,yy)=> yy*f.nx + xx;

          const u00=f.u[idx(x0,y0)], v00=f.v[idx(x0,y0)];
          const u10=f.u[idx(x1,y0)], v10=f.v[idx(x1,y0)];
          const u01=f.u[idx(x0,y1)], v01=f.v[idx(x0,y1)];
          const u11=f.u[idx(x1,y1)], v11=f.v[idx(x1,y1)];
          if([u00,v00,u10,v10,u01,v01,u11,v11].some(z => z==null)) return null;

          const u0 = u00*(1-tx) + u10*tx;
          const u1 = u01*(1-tx) + u11*tx;
          const v0 = v00*(1-tx) + v10*tx;
          const v1 = v01*(1-tx) + v11*tx;

          const u = u0*(1-ty) + u1*ty;
          const v = v0*(1-ty) + v1*ty;

          return {u,v};
        },
        _step(){
          const ctx = this._ctx;
          if(!ctx) return;

          // fade (scia)
          ctx.globalCompositeOperation = "source-over";
          ctx.fillStyle = "rgba(0,0,0,0.06)";
          ctx.fillRect(0,0,this._canvas.width,this._canvas.height);

          if(!this._field) return;

          ctx.globalCompositeOperation = "lighter";
          ctx.lineWidth = 1;

          const speedScale = 0.9; // particelle più veloci o più lente
          const maxAge = 80;
          const w = this._canvas.width, h = this._canvas.height;

          for(const p of this._particles){
            p.age++;
            if(p.age > maxAge){
              p.x = Math.random()*w;
              p.y = Math.random()*h;
              p.age = 0;
              continue;
            }

            const s = this._sampleUV(p.x, p.y);
            if(!s){
              p.x = Math.random()*w;
              p.y = Math.random()*h;
              p.age = 0;
              continue;
            }

            // u/v: assumo m/s (ICON spesso è m/s). convertiamo km/h per colore.
            const kmh = Math.sqrt(s.u*s.u + s.v*s.v) * 3.6;

            const nx = p.x + s.u * speedScale;
            const ny = p.y - s.v * speedScale; // v positivo = nord -> su schermo diminuisce y

            ctx.strokeStyle = windColor(kmh);
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(nx, ny);
            ctx.stroke();

            p.x = nx;
            p.y = ny;

            if(p.x<0 || p.x>w || p.y<0 || p.y>h){
              p.x = Math.random()*w;
              p.y = Math.random()*h;
              p.age = 0;
            }
          }
        }
      });
      return new overlay();
    }

    const windOverlay = createWindOverlay(); // aggiunta/rimossa dinamicamente

    /* =========================
       Helpers: scalar rendering
       ========================= */
    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    function scalarColor(type, v){
      // colori base: scegliamo scale semplici (puoi ritoccarle dopo)
      if(v==null) return [0,0,0,0];

      if(type==="temp"){
        // -5..35
        const x = clamp((v - (-5)) / 40, 0, 1);
        // blu -> giallo -> rosso
        const r = Math.round( 40 + 215*x );
        const g = Math.round( 60 + 180*Math.sin(x*Math.PI) );
        const b = Math.round( 255 - 255*x );
        return [r,g,b,160];
      }
      if(type==="pres"){
        // 980..1035 hPa
        const x = clamp((v - 980) / 55, 0, 1);
        const r = Math.round( 40 + 80*x );
        const g = Math.round( 120 + 120*(1-x) );
        const b = Math.round( 220 + 0*x );
        return [r,g,b,150];
      }
      if(type==="rain"){
        // 0..20 mm/h
        const x = clamp(v / 20, 0, 1);
        // trasparente -> blu -> viola
        const r = Math.round( 30 + 120*x );
        const g = Math.round( 80 + 60*(1-x) );
        const b = Math.round( 200 + 55*x );
        const a = Math.round( 40 + 200*x );
        return [r,g,b,a];
      }
      return [255,255,255,120];
    }

    function drawScalarToCanvas(field, type){
      if(!field) return;

      const ctx = scalarOverlay.ctx;
      const canvas = scalarOverlay.canvas;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const {nx, ny, bbox} = field;
      const arr = field.values; // per temp/pres/rain
      if(!nx || !ny || !bbox || !arr) return;

      const lonMin=bbox[0], latMin=bbox[1], lonMax=bbox[2], latMax=bbox[3];

      // bounding box -> pixel rect in mappa
      const p1 = map.latLngToContainerPoint([latMax, lonMin]); // top-left
      const p2 = map.latLngToContainerPoint([latMin, lonMax]); // bottom-right

      const left = Math.min(p1.x,p2.x), top = Math.min(p1.y,p2.y);
      const right= Math.max(p1.x,p2.x), bot = Math.max(p1.y,p2.y);

      const w = Math.max(1, Math.floor(right-left));
      const h = Math.max(1, Math.floor(bot-top));

      // creiamo immagine a risoluzione griglia e poi la stiriamo (no puntini)
      const img = ctx.createImageData(nx, ny);
      const data = img.data;

      for(let j=0;j<ny;j++){
        for(let i=0;i<nx;i++){
          const v = arr[j*nx+i];
          const [r,g,b,a] = scalarColor(type, v);
          const k = (j*nx+i)*4;
          data[k]=r; data[k+1]=g; data[k+2]=b; data[k+3]=a;
        }
      }

      // disegna “stirato” sul bbox
      const tmp = document.createElement("canvas");
      tmp.width = nx; tmp.height = ny;
      tmp.getContext("2d").putImageData(img,0,0);

      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(tmp, left, top, w, h);
    }

    /* =========================
       Sampling value at point
       ========================= */
    function sampleScalar(field, latlng){
      if(!field) return null;
      const {nx, ny, bbox} = field;
      const lonMin=bbox[0], latMin=bbox[1], lonMax=bbox[2], latMax=bbox[3];

      const lon = latlng.lng, lat = latlng.lat;
      if(lon<lonMin || lon>lonMax || lat<latMin || lat>latMax) return null;

      const x = (lon - lonMin)/(lonMax-lonMin)*(nx-1);
      const y = (latMax - lat)/(latMax-latMin)*(ny-1);

      const x0=Math.floor(x), y0=Math.floor(y);
      const x1=Math.min(nx-1, x0+1), y1=Math.min(ny-1, y0+1);
      const tx=x-x0, ty=y-y0;

      const idx = (xx,yy)=> yy*nx+xx;
      const a = field.values[idx(x0,y0)];
      const b = field.values[idx(x1,y0)];
      const c = field.values[idx(x0,y1)];
      const d = field.values[idx(x1,y1)];
      if([a,b,c,d].some(z => z==null)) return null;

      const v0 = a*(1-tx)+b*tx;
      const v1 = c*(1-tx)+d*tx;
      return v0*(1-ty)+v1*ty;
    }

    function sampleWind(field, latlng){
      if(!field) return null;
      const {nx, ny, bbox} = field;
      const lonMin=bbox[0], latMin=bbox[1], lonMax=bbox[2], latMax=bbox[3];
      const lon=latlng.lng, lat=latlng.lat;
      if(lon<lonMin || lon>lonMax || lat<latMin || lat>latMax) return null;

      const x = (lon - lonMin)/(lonMax-lonMin)*(nx-1);
      const y = (latMax - lat)/(latMax-latMin)*(ny-1);

      const x0=Math.floor(x), y0=Math.floor(y);
      const x1=Math.min(nx-1, x0+1), y1=Math.min(ny-1, y0+1);
      const tx=x-x0, ty=y-y0;
      const idx = (xx,yy)=> yy*nx+xx;

      const u00=field.u[idx(x0,y0)], v00=field.v[idx(x0,y0)];
      const u10=field.u[idx(x1,y0)], v10=field.v[idx(x1,y0)];
      const u01=field.u[idx(x0,y1)], v01=field.v[idx(x0,y1)];
      const u11=field.u[idx(x1,y1)], v11=field.v[idx(x1,y1)];
      if([u00,v00,u10,v10,u01,v01,u11,v11].some(z=>z==null)) return null;

      const u0 = u00*(1-tx)+u10*tx;
      const u1 = u01*(1-tx)+u11*tx;
      const v0 = v00*(1-tx)+v10*tx;
      const v1 = v01*(1-tx)+v11*tx;
      const u = u0*(1-ty)+u1*ty;
      const v = v0*(1-ty)+v1*ty;

      const kmh = Math.sqrt(u*u+v*v)*3.6;
      return {u,v,kmh};
    }

    /* =========================
       State
       ========================= */
    const state = {
      meta: {
        run: null,          // "YYYYMMDDHH"
        steps: STEPS_DEFAULT,
        stepHours: STEP_HOURS_DEFAULT,
        source: "MeteoHub / Agenzia ItaliaMeteo (ICON-2I open data)"
      },
      step: 0,

      fields: { temp:null, rain:null, pres:null, wind:null },
      active: null, // "temp"|"rain"|"pres"|"wind"|null
    };

    /* =========================
       UI elements
       ========================= */
    const el = {
      chkTemp: document.getElementById("chkTemp"),
      chkRain: document.getElementById("chkRain"),
      chkPres: document.getElementById("chkPres"),
      chkWind: document.getElementById("chkWind"),
      slider: document.getElementById("stepSlider"),
      reloadBtn: document.getElementById("reloadBtn"),
      timeLabel: document.getElementById("timeLabel"),
      runLabel: document.getElementById("runLabel"),
      ptLabel: document.getElementById("ptLabel"),
      valLabel: document.getElementById("valLabel"),
      srcLabel: document.getElementById("srcLabel"),
      infoTag: document.getElementById("infoTag"),
