// app.js

const VERSION = "5"; // cambia questo numero se vuoi forzare aggiornamento

// DOM
const elStatus = document.getElementById("status");
const btnReload = document.getElementById("btnReload");

const chkTemp = document.getElementById("chkTemp");
const chkRain = document.getElementById("chkRain");
const chkPres = document.getElementById("chkPres");
const chkWind = document.getElementById("chkWind");

const hour = document.getElementById("hour");
const hourLabel = document.getElementById("hourLabel");

const runLabel = document.getElementById("runLabel");
const sourceLabel = document.getElementById("sourceLabel");

// Utils
function pad3(n) {
  return String(n).padStart(3, "0");
}

function setStatus(msg) {
  elStatus.textContent = msg || "";
}

// Base map (raster OSM) — così la mappa “c’è sempre”
const rasterStyle = {
  version: 8,
  sources: {
    osm: {
      type: "raster",
      tiles: [
        "https://tile.openstreetmap.org/{z}/{x}/{y}.png"
      ],
      tileSize: 256,
      attribution: "© OpenStreetMap contributors"
    }
  },
  layers: [
    { id: "osm", type: "raster", source: "osm" }
  ]
};

const map = new maplibregl.Map({
  container: "map",
  style: rasterStyle,
  center: [14.0, 37.5],
  zoom: 6.2
});

map.addControl(new maplibregl.NavigationControl({ visualizePitch: true }), "top-right");

// Stato app
let meta = null;
let currentHour = 0;

const layerDefs = {
  temp: { id: "wx-temp", prefix: "temp" },
  rain: { id: "wx-rain", prefix: "rain" },
  pres: { id: "wx-pres", prefix: "pres" },
  wind: { id: "wx-wind", prefix: "wind" }
};

// Carica meta.json
async function loadMeta() {
  // IMPORTANTISSIMO: percorso relativo, niente "/data/..."
  const url = `./data/meta.json?v=${VERSION}`;
  const res = await fetch(url, { cache: "no-store" });

  if (!res.ok) {
    throw new Error(`meta.json non trovato (${res.status})`);
  }

  const j = await res.json();
  return j;
}

// Carica un layer json per un’ora
async function loadLayer(prefix, h) {
  const file = `./data/${prefix}_${pad3(h)}.json?v=${VERSION}`;
  const res = await fetch(file, { cache: "no-store" });

  if (!res.ok) {
    throw new Error(`HTTP ${res.status} su ${file}`);
  }

  // Se dentro c’è "NaN" il JSON è invalido: questa è una BOMBA che va risolta in generazione.
  // Qui provo comunque a darti un errore chiaro.
  const text = await res.text();
  if (text.includes("NaN")) {
    throw new Error(`JSON invalido: contiene NaN (${file}). Devi rigenerare i file sostituendo NaN con null.`);
  }

  return JSON.parse(text);
}

function removeIfExists(layerId) {
  if (!map.getStyle()) return;
  if (map.getLayer(layerId)) map.removeLayer(layerId);
  if (map.getSource(layerId)) map.removeSource(layerId);
}

function addGeoJsonLayer(layerId, geojson, paintType) {
  removeIfExists(layerId);

  map.addSource(layerId, {
    type: "geojson",
    data: geojson
  });

  // Qui sto assumendo che i tuoi JSON siano GeoJSON validi.
  // Se invece sono una griglia custom, dimmelo e li disegno nel modo giusto.
  if (paintType === "circle") {
    map.addLayer({
      id: layerId,
      type: "circle",
      source: layerId,
      paint: {
        "circle-radius": 4,
        "circle-opacity": 0.85
      }
    });
  } else {
    map.addLayer({
      id: layerId,
      type: "fill",
      source: layerId,
      paint: {
        "fill-opacity": 0.55
      }
    });
  }
}

async function refreshSelectedLayers() {
  if (!meta) return;

  setStatus("");

  const tasks = [];

  if (chkTemp.checked) tasks.push(renderOne("temp"));
  else removeIfExists(layerDefs.temp.id);

  if (chkRain.checked) tasks.push(renderOne("rain"));
  else removeIfExists(layerDefs.rain.id);

  if (chkPres.checked) tasks.push(renderOne("pres"));
  else removeIfExists(layerDefs.pres.id);

  if (chkWind.checked) tasks.push(renderOne("wind"));
  else removeIfExists(layerDefs.wind.id);

  try {
    await Promise.all(tasks);
  } catch (e) {
    setStatus(String(e.message || e));
  }
}

async function renderOne(key) {
  const def = layerDefs[key];
  const geojson = await loadLayer(def.prefix, currentHour);

  // Scelta “generica”: se è FeatureCollection di punti -> circle, altrimenti fill.
  const isPoints =
    geojson &&
    geojson.type === "FeatureCollection" &&
    geojson.features &&
    geojson.features[0] &&
    geojson.features[0].geometry &&
    geojson.features[0].geometry.type === "Point";

  addGeoJsonLayer(def.id, geojson, isPoints ? "circle" : "fill");
}

// Setup slider
function setupSlider() {
  const maxH = (meta && meta.times && meta.times.length) ? (meta.times.length - 1) : 0;
  hour.min = "0";
  hour.max = String(maxH);
  hour.value = "0";
  currentHour = 0;
  hourLabel.textContent = "0";

  hour.oninput = () => {
    currentHour = Number(hour.value);
    hourLabel.textContent = String(currentHour);
  };

  hour.onchange = () => {
    refreshSelectedLayers();
  };
}

// Boot
async function boot() {
  try {
    setStatus("Carico meta.json...");
    meta = await loadMeta();

    runLabel.textContent = `Run: ${meta.run || "—"} — +0h`;
    sourceLabel.textContent = `Fonte dati: ${meta.source || "—"}`;

    setupSlider();

    setStatus("Dati pronti ✅");
  } catch (e) {
    meta = null;
    runLabel.textContent = "Run: —";
    sourceLabel.textContent = "Fonte dati: —";
    setStatus(`Errore: ${String(e.message || e)}`);
  }
}

btnReload.onclick = async () => {
  await boot();
  await refreshSelectedLayers();
};

chkTemp.onchange = refreshSelectedLayers;
chkRain.onchange = refreshSelectedLayers;
chkPres.onchange = refreshSelectedLayers;
chkWind.onchange = refreshSelectedLayers;

// Aspetto che la mappa sia pronta (stile caricato)
map.on("load", async () => {
  await boot();
});
